<h1 style="text-align:center">Java基础知识总结</h1>
<h3 style="text-align:center">面向对象</h3>
---
面向对象将以前的过程中的执行者，变成了指挥者。面向对象的方式让我们不必知道实现一件事情的每一个细节，可以直接的使用工具而不是想面向过程语言一样，要知道实现过程中的每一个细节，自己制造工具才能使用工具。优化了程序开发的方式。通过构造函数来初始化对象，对象的属性保存对象的数据，用对象的方法定义对象的行为，实现模块开发的分离。面向对象有几个特征。其一是封装：将不需要对外提供的内容都隐藏起来，把属性都隐藏起来，提供公共方法对其访问。其二是继承：由多个类不断向上抽取共性内容，当类与类之间存在着所属关系时，就有了继承的前提，所属关系：‘is a’，猫是猫科动物，就是一种‘is a’关系。Java只支持单继承，但是支持多重继承。其三是多态：多态其实可以理解为一种类型转换，函数本身就具有多态性，某一种事物有不同的具体体现，有了多态以后我们可以找到对象的共性类型，直接操作共性类型做事情即可，这样可以指挥一批对象做事情，通过操作父类或接口实现。多态中关于函数调用需要重点理解一下，静态函数，调用的方法都看等号的左边，成员函数即实例函数看等号的右边。

---
<h3 style="text-align:center">接口与抽象类</h3>
抽象类中只定义抽象方法，只定义方法申明，不定义方法的具体实现，子类覆写父类的方法实现方法，把确定功能的方法写在抽象类中，不确定的方法在子类中实现。抽象类一般用于描述一个体系单元，将一组共性的内容进行抽取，定义体系中的一些基本内容，便于同类事物的使用。接口之定义方法头，接口可以被多实现，且必须实现接口中所有方法，通过接口的多实现来实现Java的多继承。抽象类是一种‘is a’的关系，接口是一种‘like a’的关系。

---
<h3 style="text-align:center">异常</h3>
---
异常顾名思义，就是程序中出现的问题，就是Java按照面向对象的思想将问题进行对象封装。Throws定义异常，当异常在程序内部不能解决的时候就通过此关键字将异常抛给调用者处理，当异常在程序内部中可以解决时通过try-catch块解决。可以同时抛出多个异常，重写的方法抛出的异常不能多余父类方法的异常，当父类没有抛出异常时子类也不能抛出异常，只能通过try-catch块处理异常。异常的处理使得程序可以优雅的结束。

---
<h3 style="text-align:center">多线程与同步</h3>
---
进程指一个应用程序运行时的内存分配内存空间而线程就是进程中得到一个执行控制单元，一条执行路径。进程负责的是应用程序的空间的标示。线程负责的是应用程序的执行顺序。一个进程至少有个主线程。创建线程有两种方式，主要用得到是第二种，实现runnable接口的方式来创建线程。线程在调用start（）时被创建，具备执行资格的同时具备执行权才能运行。Sleep（time）设置其休眠时间，时间到了就被唤醒，开始运行，wait()可以设置休眠时间也可以不设置休眠时间，不设置时间的时候就只能调用notify()唤醒线程。使用sleep（）线程结束会释放执行权但是不会释放锁，用wait时锁和执行权都会被释放。当线程只有执行资格但是没有执行权时处于临时阻塞状态。通过结束run方法的方式结束线程：定义循环的结束标志当线程处于冻结状态时不能被标记，使用thread类中的interrupt方法清除线程的冻结状态强制清除。让线程恢复具备执行资格的状态，让线程可以读到标记，并结束。多线程存在安全问题：当一个线程执行多条语句并运算同一个数据时，在执行过程中还没执行完就被其他线程执行了。可以让操作的共享数据在一个线程执行完之后才能被其它线程执行来解决这个问题。就是锁，lock对象，线程进入同步就是具备了锁，执行完离开了同步才释放锁，但是这种方式会降低性能。

---
<h3 style="text-align:center">集合框架</h3>

用于储存数据的容器，不确定的对象个数可以用集合，因为集合是可变长度的，只能储存应用数据类型，对象可以是不同数据类型。Collection中list中数据是有序，元素都有引索，元素可以重复，set是无序集，其中元素不可以有重复。接口里边都有增删改查和一些判断集合状态的方法，每个子类有其特性，根据不同的需求对其进行合理的运用。看到Array就是数组结构，有角标，查询速度很快。看到link就是链表结构：增删速度快，而且有特有方法：addFirst（） addLast（）removeFirst(),removeLast()getFirst()getLast()。看到hash就是哈希表，就要想要哈希值，就要想到唯一性，就要想到存入到该结构的中的元素必须覆盖hashCode，equals方法。看到tree就是二叉树，就要想到排序，就想要用到比较。比较的两种方式：一个是comparable：覆盖comparaeTo方法另一个是comparator：覆盖compara方法。集合：hashtable，hashmap，treemap。Map集合储存和collection有着很大的不同，collection一次存一个元素，map一次存一对元素，collection是单列集合；map是双列集合。Map中的储存的一对元素是一个键值对，键与值之间有对应关系且集合中的键是唯一的。Map集合可以转化为set通过setkeyset（），set entrySet（）；entry是map接口中的内部接口。Collection和Collections的区别：Collections是个java.util下的类，是针对集合类的一个工具类,提供一系列静态方法,实现对集合的查找、排序、替换、线程安全化（将非同步的集合转换成同步的）等操作。Collection是个java.util下的接口，它是各种集合结构的父接口，继承于它的接口主要有Set和List,提供了关于集合的一些操作,如插入、删除、判断一个元素是否其成员、遍历等。
<h3 style="text-align:center">泛型</h3>
---
使用泛型将运行时期的问题ClassCastException问题转换成了编译失败，体现在编译时期，程序员就可以解决问题，避免了强制转换的麻烦。当类中的操作二点引用数据类型不确定的时候，用泛型laibiaos。这样可以避免强制转换的麻烦，而且将运行问题转移到编译时期。泛型的通配符为’?’,?extendsE可以接收E类型或者E的子类的对象。？super E 可以接收E类型或者E的父类型对象。

---
<h3 style="text-align:center">IO流</h3>
---
流可以理解为数据的流动，就是一个数据流。IO流最终要以对象来体现，对象都存在IO包中。流的对象中有许多的对象，在不同的情况下用哪个对象更合适就需要明确流的操作规律。首先要明确源和目的。数据源：就是需要读取，可以使用两个体系：InputStream、Reader；数据汇：就是需要写入，可以使用两个体系：OutputStream、Writer；操作的数据是否是纯文本数据？如果是：数据源：Reader数据汇：Writer 	如果不是：数据源：InputStrea数据汇：OutputStream虽然确定了一个体系，但是该体系中有太多的对象，到底用哪个呢？明确操作的数据设备。数据源对应的设备：硬盘(File)，内存(数组)，键盘(System.in)数据汇对应的设备：硬盘(File)，内存(数组)，控制台(System.out)。需要在基本操作上附加其他功能吗？比如缓冲。如果需要就进行装饰。

---

