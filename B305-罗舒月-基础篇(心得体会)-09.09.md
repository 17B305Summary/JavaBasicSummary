1.JAVA的三种技术架构
&ensp;JAVA EE:Java Platform Enterprise Edition ,开发企业环境下的应用程序，主要针对web程序		   开发
&ensp;JAVA SE:Java Platform Standard Edition ,完成桌面应用程序的开发，是其他两者的基础
&ensp;JAVAME:Java Platform Micro Edition，开发电子消费产品和嵌入式设备，如手机中的程序
2.java负责编译的部分，javac负责运行的部分
3.保留字：没有赋予特殊含义，但日后准备使用过的单词
4.变量的作用域和生存期
&ensp;作用域：从变量定义的位置开始，到该变量所在大括号的结束
&ensp;生命周期:变量从定义的位置开始就在内存中活了，变量到达它所在的作用域的时候就			在内存中消失了
5.&：无论左边结果是什么右边都会参与运算
&ensp;&&：如果左边为false，右边就不会参与运算（|，||同上）
6.如果函数的返回类型为void，则可以省略return，系统会自动加上
7.区分重载：如果两个函数同名，看参数列表不同，但和返回类型无关
8.java分了5片内存区
&ensp;(1)寄存器
&ensp;(2)本地方法区
&ensp;(3)方法区
&ensp;(4)栈
&ensp;(5)堆
9.匿名对象的使用场景
&ensp;当方法只用一次时，可使用匿名对象
&ensp;当对象对成员多次调用时，不能使用匿名对象，必须给对象起名字
10.构造代码块：是给所有对象进行初始化，所有的对象都会调用一个代码块。只要对象已建立就会调用这个代&ensp;码块
&ensp;构造函数：是给与之对应的对象进行初始化的。它具有针对性。
11.this就是函数所属对象的引用，必须定义在函数中的第一行，因为构造函数是用来初始化的，否则会编译失&ensp;败
12.静态方法中不能有this,super等关键字
13.定义静态成员
&ensp;(1)成员变量：数据共享时静态化
&ensp;(2)成员函数：方法中没有调用特有数据时，就定义为静态
14.静态代码块：有静态关键字标识的一个代码块区域，定义在类中
&ensp;作用：可以完成类的初始化。静态代码块随着类的加载而执行，只执行一次，如果和主函数在同一类，优先于主函数执行
15.静态代码块、构造代码块、构造函数同时存在时的执行顺序：静态代码块 构造代码块 构造函数
16.生成java帮助文档：命令格式——javadoc -d 文件夹名 -auther -version*.java
17.单例设计模式
&ensp;(1)解决问题：保证一个类在内存中的对象唯一性
&ensp;代码体现：
&ensp;&ensp;①私有化构造函数
&ensp;&ensp;②创建私有并静态的本类对象
&ensp;&ensp;③定义公有且静态的方法返回该对象（定义一个方法，返回该对象，让其他程序可以通过方法就得&ensp;&ensp;到本类对象。作用——可控）
18.Super和this不能同时出现在构造函数中
19.抽象类中有构造方法。用于给子类对象初始化
20.抽象关键字 abstract不能和final private static 共存
21.抽象类中可以不定义抽象方法，抽象类仅仅是为了不让该类创建对象
22.模板方法设计模式
&ensp;(1)解决问题：当功能内部一部分的实现一部分是确定的，一部分是不确定的，可以把不确定的部分暴露出来，让子类去实现
23.接口的成员有固定的修饰符 
&ensp;(1)成员变量 public static final
&ensp;(2)成员函数 public abstract
24.接口可以对继承接口
25.多态在子父类的成员上体现的特点：
&ensp;(1)成员变量：不管是编译还是运行，成员变量都参考的是引用变量所属类的成员变量
&ensp;(2)成员函数：编译时，看引用变量所属类，运行时看对象所属类
&ensp;(3)静态函数：那个类的引用就是调用哪个类的静态方法（不属于对象，属于方法所在类）
26.boolean equals(Object obj)：比较的是两个对象的地址
&ensp;Class getClass()：获取任意对象运行时的所属字节码文件对象。
&ensp;int hashCode()：返回该对象的哈希码值。支持此方法是为了提高哈希表的性能。
&ensp;通常equals，toString，hashCode，在应用中都会被复写，建立具体对象的特有的内容。
27.内部类：如果A类直接想访问B类的成员，而B类又需要建立A类的对象，可以将A类设计为内部类。内部类可以&ensp;直接访问外部类的成员，但是外部类要想访问内部类，必须创建内部类的对象
28.直接访问内部类的格式：外部类名.内部类名 变量名 =  外部类对象.内部类对象;
29.如果内部类中定义了静态成员，那么这个内部类也必须是静态的
30.为什么内部类可以直接访问外部类的成员变量？
&ensp;(1)因为内部类都持有一个外部类的引用--外部类名.this
&ensp;(2)内部类可以定义在外部类的成员位置上，也可以在外部类的局部位置上，当内部类在局部位置上时，它就只能访问局部中被final修饰的局部变量
31.想要定义一个匿名内部类，这个类必须实现一个接口或者继承一个类
32.子类的catch块在父类的上面
33.Throw new Exception(...)
&ensp;Method throws...
34.函数内容如果有throw,抛出异常对象，并没有进行处理，如果函数不声明他，则会编译失败（也有特殊情况）
35.&ensp;编译时被检查的异常和运行时异常的区别
&ensp;编译被检查的异常在函数中抛出，函数必须声明
&ensp;原因：需要调用者对该异常进行处理
&ensp;运行时检查的异常在函数中抛出，函数可以不必声明
&ensp;原因：因为此时程序已经终止，由调用者对代码进行修正
36.try-finall只为了关闭资源
37.System.exit(0)//退出jvm，此时finally不执行
38.当异常出现后，子父类进行覆盖时，一些新特点：
&ensp;(1)当子类覆盖父类的方法时，父类方法抛出了异常，那么子类抛出父类异常或异常的子类
&ensp;(2)如果父类抛出多个异常，那么子类在覆盖时，只能抛出父异常的子集
39.如果父类和接口中都没有异常，子类就不会有异常，如果子类覆盖有异常，只能try不能throws，如果异常无&ensp;法解决，则throw runtimeException及其子类
40.编译命令javac -d位置（当前路径）
41.Import packa.*//这个仅仅导入了packa当前目录下的所有类，不包含子包中的
&ensp;Import packa.abc.*//导入了packa包中的子包abc下的当前所有类
42.进程：正在进行中的程序。其实进程就是一个应用程序运行时的内存分配空间。
&ensp;线程：其实就是进程中一个程序执行控制单元，一条执行路径。进程负责的是应用程序的空间的标示。线程负责的是应用程序的执行顺序。
43.解决安全问题的原理：只要将操作共享数据的语句在某一时段让一个线程执行完，在执                     行过程中，其他线程不能进来执行就可以解决这个问题
