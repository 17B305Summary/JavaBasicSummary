一、Java概述：
---------

        1.Java的三种技术构架：
	JavaEE：Java Platform Enterprise Edition，Java开发平台（企业版）；
	JavaSE：Java Platform Standard Edition，Java开发平台（标准版）；
	JavaME：Java Platform Micro Edition，Java开发平台（微小版）；
	
        2.Java环境：
    （1），JDK，Java的开发和运行环境，JRE， Java程序的运行环境，Java程序运行所需的类库+JVM（Java虚拟机）。
    （2），配置环境变量： 
    
        3.
    Javac负责编译，对.Java文件进行编译，成为jvm能识别的字节码文件（class文件）。
    Java命令负责运行，启动jvm，并执行class里的main函数。

二、Java语法基础：
-----------

    1. 关键字、保留字
    2. 标识符
    3. 常量、变量（类型、名称、初始化、作用域和生存周期）
    4. 数据类型：
    	基本数据类型：byte、short、int、long、float、double、boolean、char
    	包装数据类型：Byte、Short、Integer、Long、Float、Double、Boolean、Character
    	引用数据类型：数组、类、接口
    	自动类型转换与强制类型转换
    5. 运算符号（算数运算符、赋值运算符、比较运算符、逻辑运算符）
    6. 函数（定义函数、函数的作用、主函数）
    7. 重载（函数名同、参数列表不同、不管返回值类型）

三、面向对象：
-------

    1. 特点
    a)	复杂事情简单化
    b)	过程的执行者，变成了指挥者
    c)	符合人们的思考习惯
    2. 匿名对象用在只调用一次对象的方法的时候。
    3. 定义类，就是定义成员变量和成员函数。
    4. 成员修饰符，private、protected、缺省、public的作用范围。
    5. 构造函数
    a)	作用：对对象进行初始化。
    b)	特点：构造函数名与所在对象名相同，不定义返回值类型，没有具体返回值。
    c)	对象创建时，需初始化才能使用。
    d)	自动构建无参构造函数。
    e)	多个构造函数，通过重载体现。
    6. 面向对象的特征之一——封装。
    7. this代表所在函数所属对象的引用。
    8. static（修饰成员变量和函数）
    a)	对象数据的共享。
    b)	被静态修饰的成员，可以用——类名.静态方式调用。
    c)	随着类的加载而加载，优于对象存在（此时不能用this和super）
    
    9. 继承
    a)	提高了代码的复用性，让类与类之间产生了关系也是多态的前提
    b)	成员变量（super调用父类的同属性）
    c)	成员函数（存在重写）
    d)	构造函数（先运行父类的构造函数）
    e)	final特点：
    1：这个关键字是一个修饰符，可以修饰类，方法，变量。
    2：被final修饰的类是一个最终类，不可以被继承。
    3：被final修饰的方法是一个最终方法，不可以被覆盖。
    4：被final修饰的变量是一个常量，只能赋值一次。
    10. 抽象类
    特点：
    a)	抽象方法只能定义在抽象类中，抽象类和方法必须被abstract修饰。
    b)	抽象方法只定义方法声明。
    c)	抽象类不可被实例化。
    d)	只有通过子类继承抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。
    细节：
    a)	抽象类有构造函数。
    b)	抽象类中可以定义非抽象方法。
    c)	抽象类中可以不定义抽象方法（定义的目的是为了不让抽象类直接实例化）。
    
    11. 接口
    interface Inter{
    	public static final int x = 3;
    	public abstract void show();
    }
    a)	实例化和抽象类一样。
    b)	类与类是继承，类与接口是实现。
    c)	接口之间可以实现多继承，接口和类可以多实现。
    d)	特点： 
    1：接口是对外提供的规则。
    2：接口是功能的扩展。
    3：接口的出现降低了耦合性。
    抽象类和接口的区别：
    1：抽象类只能被继承，而且只能单继承。
    接口需要被实现，而且可以多实现。 
    2：抽象类中可以定义非抽象方法，子类可以直接继承使用。
    接口中都有抽象方法，需要子类去实现。
    3：抽象类使用的是  is a 关系。
    接口使用的 like a 关系。 
    4：抽象类的成员修饰符可以自定义。
    接口中的成员修饰符是固定的。全都是public的。
    
    12. 多态
    a)	体现：父类引用或者接口的引用指向了自己的子类对象。//Animal a = new Cat();
    多态的好处：提高了程序的扩展性。
    b)	多态的弊端：当父类引用指向子类对象时，虽然提高了扩展性，但是只能访问父类中具备的方法，不可以访问子类中特有的方法。(前期不能使用后期产生的功能，即访问的局限性)
    c)	多态的前提：
    	1：必须要有关系，比如继承、或者实现。
    	2：通常会有覆盖操作。
    成员变量 --- 编译运行都看 = 左边。
    成员函数 --- 编译看 = 左边，运行看 = 右边。
    静态函数 --- 编译运行都看 = 左边。
    
    13. Object（所有类的直接或者间接父类）
    boolean equals(Object obj)：
    String toString()：
    
    14. 内部类
    如果A类需要直接访问B类中的成员，而B类又需要建立A类的对象。这时,为了方便设计和访问，直接将A类定义在B类中。就可以了。A类就称为内部类。内部类可以直接访问外部类中的成员。而外部类想要访问内部类，必须要建立内部类的对象。
    
    15. 异常
    try {
    	需要被检测的代码；
    }
    catch(异常类 变量名){
    	异常处理代码；
    }
    fianlly{
    	一定会执行的代码；
    }
    a)	异常处理原则：功能抛出几个异常，功能调用如果进行try处理，需要与之对应的catch处理代码块，这样的处理有针对性，抛几个就处理几个。
    b)	特殊情况：try对应多个catch时，如果有父类的catch语句块，一定要放在下面。
    c)	throw 和throws关键字的区别
    throw用于抛出异常对象，后面跟的是异常对象；throw用在函数内。
    throws用于抛出异常类，后面跟的异常类名，可以跟多个，用逗号隔开。throws用在函数上。
    16. 多线程
    a)	一个进程中包含多个线程时，就是一个多线程应用程序。
    b)	Start方法：（1）启动线程。（2）让jvm调用run方法。
    c)	创建线程方法一：
    步骤：
    1，定义类继承Thread类；
    2，目的是复写run方法，将要让线程运行的代码都存储到run方法中；
    3，通过创建Thread类的子类对象，创建线程对象；
    4，调用线程的start方法，开启线程，并执行run方法。
    d)	创建线程方法二：
    步骤：
    1，定义类实现Runnable接口。
    2，覆盖接口中的run方法（用于封装线程要运行的代码）。
    3，通过Thread类创建线程对象；
    4，将实现了Runnable接口的子类对象作为实际参数传递给Thread类中的构造函数。
    为什么要传递呢？因为要让线程对象明确要运行的run方法所属的对象。
    5，调用Thread对象的start方法。开启线程，并运行Runnable接口子类中的run方法。
    e)	解决多线程安全问题：将操作共享数据的语句在某一时段让一个线程执行完，在执行过程中，其他线程不能进来执行就可以解决这个问题。
    
    17. 同步
    好处：解决了线程安全问题。
    弊端：相对降低性能，因为判断锁需要消耗资源，产生了死锁。
    
    18. API（一些预先定义的函数）
    
    19. 集合框架
    特点：
    用于存储对象。
    集合是可变长度的，数据是确定的。
    集合和数组的区别：
    	数组长度固定，集合可变长度。
    	数组即可存储基本数据类型和引用数据类型，集合只能存储引用数据类型。
    	数组必存储同一数据类型，集合的对象可以是不同类型。
    Collection：
    List：有序，有索引，可重复。
    Set：无序，不可重复。
    方法：
    	add(object)
    	addAll(Collection) ：添加一个集合中的所有元素。
    	
    	clear()：将集合中的元素全删除，清空集合。
    	remove(obj) ：删除集合中指定的对象。注意：删除成功，集合的长度会改变。
    	removeAll(collection) ：删除部分元素。部分元素和传入Collection一致。
    
    	boolean contains(obj) ：集合中是否包含指定元素 。
    	boolean containsAll(Collection) ：集合中是否包含指定的多个元素。
    	boolean isEmpty()：集合中是否有元素。
    
    	int size()：集合中有几个元素。
    	Iterator  iterator()：迭代器,获取所有元素
    	toArray();将集合变成数组
    iterator接口（迭代器）：
    public static void main(String[] args) {
    		Collection coll = new ArrayList();
    		coll.add("abc0");
    		coll.add("abc1");
    		coll.add("abc2");
    		//--------------方式1----------------------
    		Iterator it = coll.iterator();
    		while(it.hasNext()){
    			System.out.println(it.next());
    		}
    		//---------------方式2用此种----------------------
    		for(Iterator it = coll.iterator();it.hasNext(); ){
    			System.out.println(it.next());
    		}
    	}
    List接口：
    List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。
    ArrayList：底层的数据结构是数组,线程不同步，ArrayList替代了Vector，查询元素的速度非常快。
    	LinkedList：底层的数据结构是链表，线程不同步，增删元素的速度非常快。
    	Vector：底层的数据结构就是数组，线程同步的，Vector无论查询和增删都巨慢。
    List接口的方法。
    ListIterator：List集合特有的迭代器。
    LinkedList含有特有方法。
    Set接口：
    Set接口中的方法和Collection中方法一致的。Set接口取出方式只有一种，迭代器。
    HashSet：底层数据结构是哈希表，线程是不同步的。无序，高效；HashSet集合保证元素唯一性：通过元素的hashCode方法，和equals方法完成的。
      LinkedHashSet：有序，hashset的子类。
    TreeSet：对Set集合中的元素的进行指定顺序的排序。不同步。TreeSet底层的数据结构就是二叉树。
    TreeSet：用于对Set集合进行元素的指定顺序排序，需要可比性（Comparable接口）。
    Comparable接口：需要元素对象实现Comparable接口，覆盖compareTo方法。
    Comparator接口：让集合自身具备比较性，定义一个实现了Comparator接口的比较器，并覆盖compare方法。
    Map集合：
    Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。
    HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable。
    TreeMap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。
    获取map中的所有元素：
    map中是没有迭代器的，collection具备迭代器，只要将map集合转成Set集合，可以使用迭代器了。
    Collection和map：
    当存储的是一个元素时，就用Collection。当存储对象之间存在着映射关系时，就使用Map集合。
    Collections：
    给集合操作提供更多的功能，这个类不需要创建对象，内部提供的都是静态方法。
    
    20. 递归：自身调用自身，必须要定义递归完成的条件，返回值是一层一层往上。
    
    21. 对象序列化：将对象写入到硬盘上，用到Serializable接口。
