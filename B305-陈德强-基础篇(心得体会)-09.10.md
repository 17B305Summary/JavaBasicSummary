# java知识总结
### 一、Java语法基础
1、数据类型：
1 ） ：基本数据类型：byte、short、int、long、float、double、char、boolean
2 ） ：引用数据类型: 数组、类、接口。
级别从低到高为：byte,char,short(这三个平级)-->int-->float-->long-->double
自动类型转换：从低级别到高级别，系统自动转的；
强制类型转换：什么情况下使用?把一个高级别的数赋给一个别该数的级别低的变量；
2、运算符号
a、& 和 和  &&： 区别： 
& ：无论左边结果是什么，右边都参与运算。
&&: 短路与，如果左边为 false，那么右边不参数与运算。
b、| |  和| ||  区别：
|：两边都运算。
|| ：短路或，如果左边为 true，那么右边不参与运算。
3、函数
a、java  中的函数的定义格式：
修饰符 返回值类型  函数名( (参数类型  形式参数1型 ，参数类型  形式参数 1 ， …) )
{ 
执行语句；
return  返回值；
} 
b、重载的定义是：在一个类中，如果出现了两个或者两个以上的同名函数，只要它们的参数的个数，或者参数的类型不同，即可称之为该函数重载了。
如何区分重载：当函数同名时，只看参数列表。和返回值类型没关系。

4、注意：
a、switch 后面的小括号中的变量应该是 byte,char,short,int 四种类型中的一种。

5、java 分了5片内存。
1 ：寄存器。2 ：本地方法区。3 ：方法区。4 ：栈。5 ：堆。
栈：存储的都是局部变量 ( 函数中定义的变量，函数上的参数，语句中的变量 )；只	要数据运算完成所在的区域结束，该数据就会被释放。
堆：用于存储数组和对象，也就是 实体。啥是实体啊？就是用于封装多个数据的。
1 ：每一个实体都有内存首地址值。
2 ：堆内存中的变量。
### 二、面向对象
a、构造代码块和构造函数有什么区别？
构造代码块：是给所有的对象进行初始化，也就是说，所有的对象都会调用一个代码块。只要对象一建立就会调用这个代码块。
构造函数：是给与之对应的对象进行初始化。它具有针对性。
b、创建一个对象都在内存中做了什么事情？
1 ：先将硬盘上指定位置的 Person.class 文件加载进内存。
2 ：执行 main 方法时，在栈内存中开辟了 main 方法的空间(压栈-进栈)，然后在 main 方法的栈区分配了一
个变量 p。
3 ：在堆内存中开辟一个实体空间，分配了一个内存首地址值。new
4 ：在该实体空间中进行属性的空间分配，并进行了默认初始化。
5 ：对空间中的属性进行显示初始化。
6 ：进行实体的构造代码块初始化。
7 ：调用该实体对应的构造函数，进行构造函数初始化。（）
8 ：将首地址赋值给 p ，p 变量就引用了该实体。(指向了该对象)
c、封装（面向对象特征之一 ）： 是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。
好处： 将变化隔离；便于使用；提高重用性；安全性。
封装原则：将不需要对外提供的内容都隐藏起来，把属性都隐藏，提供公共方法对其访问。
注意 ：
1、用 this 调用构造函数 ，必须定义在构造函数的第一行。因为构造函数是用于初始化的，所以初始化动作一定要执行。
2、静态方法中不能使用  this ，super 关键字（因为 this 代表对象，而静态在时，有可能没有对象，所以 this 无法使用。）。
3、静态成员分两种：
1，成员变量。（数据共享时静态化）
该成员变量的数据是否是所有对象都一样：
如果是，那么该变量需要被静态修饰，因为是共享的数据。 
如果不是，那么就说这是对象的特有数据，要存储到对象中。 
2，成员函数。（方法中没有调用特有数据时就定义成静态）
如果判断成员函数是否需要被静态修饰呢？
只要参考，该函数内是否访问了对象中的特有数据：
如果有访问特有数据，那方法不能被静态修饰。
如果没有访问过特有数据，那么这个方法需要被静态修饰。

4、成员变量和静态变量的区别：
1，成员变量所属于对象。所以也称为实例变量。
静态变量所属于类。所以也称为类变量。
2，成员变量存在于堆内存中。
静态变量存在于方法区中。
3，成员变量随着对象创建而存在。随着对象被回收而消失。
静态变量随着类的加载而存在。随着类的消失而消失。
4，成员变量只能被对象所调用 。
静态变量可以被对象调用，也可以被类名调用。
成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。

### 三、继承
a、子类的所有构造函数中的第一行，其实都有一条隐身的语句super()
b、为什么子类对象初始化时，都需要调用父类中的函数？(为什么要在子类构造函数的第一行加入这个super()?)
b、因为子类继承父类，会继承到父类中的数据，所以必须要看父类是如何对自己的数据进行初始化的。所以子类在进行对象初始化时，先调用父类的构造函数，这就是子类的实例化过程。
c、注意：子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super(); 
如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。
如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。
d、final特点：
1：这个关键字是一个修饰符，可以修饰类，方法，变量。
2：被final修饰的类是一个最终类，不可以被继承。
3：被final修饰的方法是一个最终方法，不可以被覆盖。
4：被final修饰的变量是一个常量，只能赋值一次。
### 四、抽象类
a、抽象类中是否可以定义非抽象方法？
	可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。只不过，比一般类多了一个抽象函数。而且比一般类少了一个创建对象的部分。
b、抽象关键字abstract和哪些不可以共存？final ,	private , static 
c、抽象类中可不可以不定义抽象方法？可以。抽象方法目的仅仅为了不让该类创建对象。
### 五、接口
a、关键字interface
b、 成员变量：public static final 
	成员方法：public abstract 
c、接口可以被多实现，接口可以多继承接口，接口的出现避免了单继承的局限性。
d、抽象类和接口的区别：
1：抽象类只能被继承，而且只能单继承。
接口需要被实现，而且可以多实现。 
2：抽象类中可以定义非抽象方法，子类可以直接继承使用。
接口中都有抽象方法，需要子类去实现。
3：抽象类使用的是  is a 关系。
接口使用的 like a 关系。 
4：抽象类的成员修饰符可以自定义。
接口中的成员修饰符是固定的。全都是public的。
### 六、多态
a、关键字 instanceof 判断一个对象是否所属于指定的类型。
b、多态在子父类中的成员上的体现的特点：
1、无论编译和运行，成员变量参考的都是引用变量所属的类中的成员变量
2、成员函数，编译看引用型变量所属的类，运行看对象所属的类
c、静态函数
编译时期：参考的是引用型变量所属的类中是否有调用的成员。
运行时期：也是参考引用型变量所属的类中是否有调用的成员。
### 七、object
a、boolean equals(Object obj)：用于比较两个对象是否相等，其实内部比较的就是两个对象地址。
b、String toString()：默认返回的格式：类名@哈希值 = getClass().getName() + '@' + Integer.toHexString(hashCode())。
c、Class getClass()：获取任意对象运行时的所属字节码文件对象。
d、int hashCode()：返回该对象的哈希码值。
### 八、内部类
a、使用条件：如果A类需要直接访问B类中的成员，而B类又需要建立A类的对象。这时,为了方便设计和访问，直接将A类定义在B类中。就可以了。A类就称为内部类。内部类可以直接访问外部类中的成员。而外部类想要访问内部类，必须要建立内部类的对象。
b、当内部类定义在外部类中的成员位置上，可以使用一些成员修饰符修饰 private、static。
c、默认修饰符
直接访问内部类格式：外部类名.内部类名 变量名 =  外部类对象.内部类对象;
Outer.Inner in = new Outer.new Inner();//这种形式很少用。
d、私有修饰符。
通常内部类被封装，都会被私有化，因为封装性不让其他程序直接访问。 
e、静态修饰符。
如果内部类被静态修饰，相当于外部类，会出现访问局限性，只能访问外部类中的静态成员。
f、	注意；如果内部类中定义了静态成员，那么该内部类必须是静态的。
g、内部类编译后的文件名为：“外部类名$内部类名.java”；
h、为什么内部类可以直接访问外部类中的成员呢？
那是因为内部中都持有一个外部类的引用。这个是引用是 外部类名.this 
内部类可以定义在外部类中的成员位置上，也可以定义在外部类中的局部位置上。
当内部类被定义在局部位置上，只能访问局部中被final修饰的局部变量。
i、匿名内部类：
没有名字的内部类。就是内部类的简化形式。一般只用一次就可以用这种形式。匿名内部类其实就是一个匿名子类对象。想要定义匿名内部类：需要前提，内部类必须继承一个类或者实现接口。
j、匿名内部类的格式：
new 父类名&接口名(){ 定义子类成员或者覆盖父类方法 }.方法。
k、匿名内部类的使用场景：
当函数的参数是接口类型引用时，如果接口中的方法不超过3个。可以通过匿名内部类来完成参数的传递。
其实就是在创建匿名内部类时，该类中的封装的方法不要过多，最好两个或者两个以内。
### 九、异常
a、throw 和throws关键字的区别：
throw用于抛出异常对象，后面跟的是异常对象；throw用在函数内。
throws用于抛出异常类，后面跟的异常类名，可以跟多个，用逗号隔开。throws用在函数上。
b、如果父类或者接口中的方法没有抛出过异常，那么子类是不可以抛出异常的，如果子类的覆盖的方法中出现了异常，只能try不能throws。
c、使用环境：如果功能内部如果出现异常，如果内部可以处理，就用try；如果功能内部处理不了，就必须声明出来，让调用者处理。
### 十、多线程
 a、创建线程方式一：继承Thread ，由子类复写run方法。
步骤：
1，定义类继承Thread类；
2，目的是复写run方法，将要让线程运行的代码都存储到run方法中；
3，通过创建Thread类的子类对象，创建线程对象；
4，调用线程的start方法，开启线程，并执行run方法。
b、创建线程的第二种方式：实现一个接口Runnable。（多使用第二种方式）
步骤：
1，定义类实现Runnable接口。
2，覆盖接口中的run方法（用于封装线程要运行的代码）。
3，通过Thread类创建线程对象；
4，将实现了Runnable接口的子类对象作为实际参数传递给Thread类中的构造函数。要让线程对象明确要运行的run方法所属的对象。
5，调用Thread对象的start方法。开启线程，并运行Runnable接口子类中的run方法。
c、线程状态：
被创建：start()
运行：具备执行资格，同时具备执行权；
冻结：sleep(time),wait()—notify()唤醒；线程释放了执行权，同时释放执行资格；
临时阻塞状态：线程具备cpu的执行资格，没有cpu的执行权；
消亡：stop()
d、实现Runnable接口可以避免单继承的局限性。
e、线程安全及解决方案：
 在某一个时刻被一个线程执行时，还没有执行完，就被其他线程执行了。
将操作共享数据的语句在某一时段让一个线程执行完，在执行过程中，其他线程不能进来执行就可以解决这个问题。
f、同步
优点：解决了线程安全。
弊端：降低了性能。
前提：1，必须要有两个或者两个以上的线程，才需要同步。
2，多个线程必须保证使用的是同一个锁。
同步函数：其实就是将同步关键字定义在函数上，让函数具备了同步性。
当同步函数被static修饰时，静态函数在加载时所属于类，这时有可能还	没有该类产生的对象，但是该类的字节码文件加载进内存就已经被封装成了	对象，这个对象就是该类的字节码文件对象。
同步代码块和同步函数的区别：
同步代码块使用的锁可以是任意对象。
同步函数使用的锁是this，静态同步函数的锁是该类的字节码文件对象。
在一个类中只有一个同步，可以使用同步函数。如果有多同步，必须使用同步代码块，来确定不同的锁。所以同步代码块相对灵活一些。
wait和sleep区别：
wait：可以指定时间也可以不指定时间。不指定时间，只能由对应的notify或者notifyAll来唤醒，线程会释放执行权，而且线程会释放锁。
sleep：必须指定时间，时间到自动从冻结状态转成运行状态(临时阻塞状态)。线程会释放执行权，但不是不释放锁。
g、Lock接口
1、同步是隐示的锁操作，而Lock对象是显示的锁操作
#### 十一、string
a、注意：
1、字符串一旦被初始化，就不可以被改变，存放在方法区中的常量池中。
2、String s2 = new String("abc"); // s2指向的内容中有两个对象abc、new。
### 十二、stringBuffer和stringBuilder
区别：
StringBuffer线程安全。
StringBuilder线程不安全。

单线程操作，使用StringBuilder 效率高。
多线程操作，使用StringBuffer 安全。
### 十三、集合框架
a、集合与数组的区别
1：数组是固定长度的；集合可变长度的。
2：数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据		类型。
3：数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。
b、使用原则：参阅顶层内容。建立底层对象。
c、Collection
1、list：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。
set：无序(存入和取出顺序有可能不一致)，不可以存储重复元素。必须保证元素唯一性。
d、Iterator
1、作用：用于取集合中的元素（降低了取出元素和具体集合的耦合性。）
e、List
1、特点：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。
2、ArrayList：底层的数据结构是数组,线程不同步，ArrayList替代了Vector，查询元素的速度非常快。
	 LinkedList：底层的数据结构是链表，线程不同步，增删元素的速度非常快。
	 Vector：底层的数据结构就是数组，线程同步的，Vector无论查询和增删都巨慢。
3、可变长度：
ArrayList：是按照原数组的50%延长。构造一个初始容量为 10 的空列表。
Vector：是按照原数组的100%延长。
f、Set接口
1、set接口取出接口的方法只有一种：迭代器。
        2、HashSet:底层数据结构是哈希表，线程是不同步的。无序，高效；
           LinkedHashSet:有序，hashset的子类。
           TreeSet:指定排序，不同步，二叉树。
3、
对于ArrayList集合，判断元素是否存在，或者删元素底层依据都是equals	方法。
对于HashSet集合，判断元素是否存在，或者删除元素，底层依据的是hashCode方法和equals方法。
4、
注意：在进行比较时，如果判断元素不唯一，比如，同姓名，同年龄，才视为同一个人。
	在判断时，需要分主要条件和次要条件，当主要条件相同时，再判断次要条件，按照次要条件排序。

5、TreeSet集合排序有两种方式，Comparable和Comparator区别：
1：让元素自身具备比较性，需要元素对象实现Comparable接口，覆盖compareTo方法。
2：让集合自身具备比较性，需要定义一个实现了Comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给TreeSet集合的构造函数。
第二种方式较为灵活。

g、Map集合
1、
Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。
HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable.
TreeMap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。
2、
Map集合存储和Collection有着很大不同：
Collection一次存一个元素；Map一次存一对元素。
Collection是单列集合；Map是双列集合。
Map中的存储的一对元素：一个是键，一个是值，键与值之间有对应(映射)关系。
特点：要保证map集合中键的唯一性。
3、
把map集合转成set的方法：
Set keySet();
Set entrySet();//取的是键和值的映射关系。


    4、取出map集合中所有的元素：keySet（）方法、entrySet（）方法。
5、使用集合的技巧
1、看到Array就是数组结构，有角标，查询速度很快。
2、看到link就是链表结构：增删速度快，而且有特有方法。addFirst； addLast； removeFirst()； removeLast()； getFirst()；getLast()；
3、看到hash就是哈希表，就要想要哈希值，就要想到唯一性，就要想到存入到该结构的中的元素必须覆盖hashCode，equals方法。
4、看到tree就是二叉树，就要想到排序，就想要用到比较。
        5、使用集合：当存储的是一个元素时，就用Collection。当存储对象之间存在着映射关系时，就使用Map集合。保证唯一，就用Set。
证唯一，就用List。
h、Collections
 1、优点：提供了更多的功能。这个类不需要创建对象，内部提供的都是       静态方法。
       2、将非同步集合转成同步集合的方法：Collections中的XXX synchronizedXXX(XXX);
 3、Collection 和 Collections的区别：
Collections是个java.util下的类，是针对集合类的一个工具类,提供一系列静态方法,实现对集合的查找、排序、替换、线程安全化（将非同步的集合转换成同步的）等操作。
Collection是个java.util下的接口，它是各种集合结构的父接口，继承于它的接口主要有Set和List,提供了关于集合的一些操作,如插入、删除、判断一个元素是否其成员、遍历等。
i、Arrays
1、增强for循环：foreach语句，foreach简化了迭代器。
格式：// 增强for循环括号里写两个参数，第一个是声明一个变量，第二个就是需要迭代的容器
for( 元素类型 变量名 : Collection集合 & 数组 ) {
	…
}
2、高级for循环和传统for循环的区别：
高级for循环在使用时，必须要明确被遍历的目标。这个目标，可以是Collection集合或者数组，如果遍历Collection集合，在遍历过程中还需要对元素进行操作，比如删除，需要使用迭代器。
如果遍历数组，还需要对数组元素进行操作，建议用传统for循环因为可以定义角标通过角标操作元素。如果只为遍历获取，可以简化成高级for循环，它的出现为了简化书写。
3、高级for循环不可以遍历map集合。但可以将map转成set后再使用foreach语句。
4、集合迭代注意问题：在迭代集合的过程中，不能对集合进行增删操作（会报并发访问异常）；可以用迭代器的方法进行操作（子类listIterator：有增删的方法）。
5、增强for循环注意问题：在使用增强for循环时，不能对元素进行赋值；

### 十四泛型：
1、作用：在编译时检查出错误。
2、优点：避免强制转换的麻烦。
3、表现格式：<>(带有<>的类或接口)。
4、数据类型：引用数据类型。
5、生产周期：存在于编译时期，覆灭于运行时期——泛型的擦除
6、泛型补偿：运行时使用者不用对元素类型再做转换动作。
7、适用环境：当类中的操作的引用数据类型不确定的时候，以前用的Object来进行扩展的，现在可以用泛型来表示。这样可以避免强转的麻烦，而且将运行问题转移到的编译时期。
8、泛型的应用：
a、泛型类——将泛型定义在类上。
b、当方法操作的引用数据类型不确定的时候，可以将泛型定义在方法上。
c、静态方法上的泛型：静态方法无法访问类上定义的泛型。如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。
d、泛型接口。
9、通配泛型的三种形式：
a、？——非受限通配（等同于？ extends Object）。
b、？ extends T——受限通配（上限：可接受T类或T的子类对象）。
c、？ super T——受限通配（下限：可接受T类或T的父类对象）。
10、注意：
a、不能使用泛型类型参数来创建实例。
b、不能使用泛型类型参数来创建数组。
c、不能在静态环境中使用类的泛型类型参数。
d、异常类中不能使用泛型类型参数。
e、泛型到底代表什么类型取决于调用者传入的类型，如果没传，默认是 Object 类型。
f、使用带泛型的类创建对象时，等式两边指定的泛型必须一致。原因：编译器检查对象调用方法时只看变量，然而程序运行期间调用方法时就要考虑对象具体类型了
g、等式两边可以在任意一边使用泛型，在另一边不使用(考虑向后兼容)。
### 十五、流
1、字节流：InputStream  OutputStream；字符流：Reader  Writer。
2、调用Writer类中的write方法写入字符串。字符串并未直接写入到目的地中，而是写入到了流中，(其实是写入到内存缓冲区中)。
3、读取数据的第二种方式：第二种方式较为高效，自定义缓冲区。
import java.io.*;
class FileReaderDemo2 {
	public static void main(String[] args) throws IOException {
		FileReader fr = new FileReader("demo.txt"); //创建读取流对象和指定文件关联。
		//因为要使用read(char[])方法，将读取到字符存入数组。所以要创建一个字符数组，一般数组的长度都是1024的整数倍。
		char[] buf = new char[1024];
		int len = 0;
		while(( len=fr.read(buf)) != -1) {
			System.out.println(new String(buf,0,len));
		}
		fr.close();
	}
}
l、字符流
1、reader
BufferedReader：从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。 可以指定缓冲区的大小，或者可使用默认的大小。大多数情况下，默认值就足够大了。
LineNumberReader：跟踪行号的缓冲字符输入流。此类定义了方法 setLineNumber(int) 和 getLineNumber()，它们可分别用于设置和获取当前行号。
InputStreamReader：是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集。
FileReader：用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的。要自己指定这些值，可以先在 FileInputStream 上构造一个 InputStreamReader。
2、writer
BufferedWriter：将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。
OutputStreamWriter：是字符流通向字节流的桥梁：可使用指定的 charset 将要写入流中的字符编码成字节。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集。
FileWriter：用来写入字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是可接受的。要自己指定这些值，可以先在 FileOutputStream 上构造一个 OutputStreamWriter。
m、字节流
1、InputStream：是表示字节输入流的所有类的超类。
     |--- FileInputStream：从文件系统中的某个文件中获得输入字节。哪些文件可用取决于主机环境。FileInputStream 用于读取诸如图像数据之类的原始字节流。要读取字符流，请考虑使用 FileReader。
     |--- FilterInputStream：包含其他一些输入流，它将这些流用作其基本数据源，它可以直接传输数据或提供一些额外的功能。
     |--- BufferedInputStream：该类实现缓冲的输入流。
2、OutputStream：此抽象类是表示输出字节流的所有类的超类。
     |--- FileOutputStream：文件输出流是用于将数据写入 File 或 FileDescriptor 的输出流。
     |--- FilterOutputStream：此类是过滤输出流的所有类的超类。
     |--- BufferedOutputStream：该类实现缓冲的输出流。
### 十六、file类
1、创建：对文件——createNewFile()
     对文件夹——mkdir（）
2、注意：deleteOnExit()——在删除文件夹时，必须保证这个文件夹中没有任何内容，才可以将该文件夹用delete删除。
3、Java.util.Properties：一个可以将键值进行持久化存储的对象。Map--Hashtable的子类。
4、PrintWriter：具备了PrintStream的特点同时，还有自身特点：
该对象的目的地有四个：1：File对象。2：字符串路径。3：字节输出流。4：字符输出流。开发时尽量使用PrintWriter。
5、SequenceInputStream：序列流，作用就是将多个读取流合并成一个读取流。实现数据合并。
6、合并原理：多个读取流对应一个输出流。
切割原理：一个读取流对应多个输出流。
7、RandomAccessFile:
特点：
1：该对象即可读取，又可写入。
2：该对象中的定义了一个大型的byte数组，通过定义指针来操作这个数组。
3：可以通过该对象的getFilePointer()获取指针的位置，通过seek()方法设置指针的位置。
4：该对象操作的源和目的必须是文件。 
5：其实该对象内部封装了字节读取流和字节写入流。
注意：实现随机访问，最好是数据有规律。
8、管道流：管道读取流和管道写入流可以像管道一样对接上，管道读取流就可以读取管道写入流写入的数据。
注意：需要加入多线程技术，因为单线程，先执行read，会发生死锁，因为read方法是阻塞式的，没有数据的read方法会让线程等待。
9、对象的序列化：目的：将一个具体的对象进行持久化，写入到硬盘上。
注意：静态数据不能被序列化，因为静态数据不在堆内存中，是存储在静态方法区中。
10、DataOutputStream、DataInputStream：专门用于操作基本数据类型数据的对象。
11、（不需要关闭）
ByteArrayInputStream：源：内存 
ByteArrayOutputStream：目的：内存。 
### 十七、正则表达式
1、优点：对字符串的复杂操作变得更为简单。
2、组：用小括号标示，每定义一个小括号，就是一个组，而且有自动编号，从1开始。
只要使用组，对应的数字就是使用该组的内容。数组要加\\。
(aaa(wwww(ccc))(eee))技巧，从左括号开始数即可。有几个左括号就是几组。


